# C++ 포인터 정리

## 1. 포인터 기본 개념
- 포인터 변수는 **다른 변수의 주소를 저장**하는 변수
- 선언: `자료형* 포인터명;`
- 예: `int* p;` → `int`형 변수의 주소 저장 가능
- 주소 할당: `p = &변수;`
- 값 접근: `*p` → 포인터가 가리키는 변수의 실제 값

### 포인터 연산과 괄호
- `*p + i` → 먼저 `*p` 수행, `p`가 가리키는 값에 `i`를 더함
- `*(p + i)` → `p`가 가리키는 주소에서 `i`번째 요소로 이동 후 값 가져오기
- 값 변경 시
```cpp
*(p + i) = *(p + i) * 2; // i번째 요소 값을 2배로 저장
```
- 괄호 사용 여부에 따라 연산 우선순위가 달라짐 → 정확히 구별 필요

## 2. 포인터와 함수
- 함수에서 포인터를 매개변수로 받으면 **원본 변수 수정 가능**
```cpp
void change(int* ptr) {
    *ptr = 200; // 원본 변수 값 변경
}
int num = 100;
change(&num); // num = 200
```
- 일반 변수는 복사본만 전달되므로 원본에 영향 없음

## 3. 배열과 포인터
- 배열명은 배열 첫 번째 요소의 주소로 사용 가능
```cpp
int arr[5] = {1,2,3,4,5};
int* p = arr; // p는 arr[0] 주소를 가리킴
```
- 순회 예시
```cpp
int length = sizeof(arr) / sizeof(arr[0]);
for(int i=0; i<length; ++i) {
    sum += *(p+i); // i번째 요소 접근
}
```
- `sizeof(arr)` → 배열 전체 크기(byte)
- `sizeof(arr[0])` → 한 요소 크기(byte)
- 배열 길이 계산: `sizeof(arr) / sizeof(arr[0])`

## 4. 실무 팁
- 배열 순회할 때 직접 숫자 사용보다는 `sizeof`로 길이 계산 권장 (배열 길이 변경에 안전)
- 포인터로 배열 접근 시 `*(p + i)` 사용 권장 → 읽기/쓰기 가능
- `(*p + i)`는 **첫 번째 요소 값에 i를 더한 값**이므로 의도와 맞는지 주의

## 5. 할당과 비교
- `=` : 값 저장(할당)
- `==` : 값 비교
- 포인터 사용 시도 동일, `=`로 값 할당 가능

## 6. 오늘 문제에서 헷갈렸던 점 요약
- `(*p + i)` vs `*(p + i)` 구분
- 포인터를 통한 배열 요소 순회와 연산
- `sizeof`를 통한 배열 길이 계산 원리
- 포인터로 함수 안에서 원본 변수 수정 가능
- 괄호 위치와 연산 우선순위

---
**Tip:** 오늘 배운 포인터는 배열, 함수, 동적메모리와 연계되어 사용될 때 진가가 나타남. 헷갈릴 때마다 위 내용을 참조하여 코드를 디버깅하며 익히는 습관 필요.

